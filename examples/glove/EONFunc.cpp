
//
// This file is automatically generated by SciVi::ES v0.1
//

#include "EONFunc.h"

#include <Wire.h>
#include <ESP8266WiFi.h>
#include <Hash.h>
#include <ESP8266WebServer.h>
#include <WebSocketsServer.h>
#include <ESP8266mDNS.h>


#ifdef EON_DEBUG
#define LOG(...) printf(__VA_ARGS__)
#define MCU(...)
#else
#define LOG(...)
#define MCU(...) __VA_ARGS__
#endif // EON_DEBUG

MDNSResponder g_MDNS;
extern WebSocketsServer g_webSocket;

using namespace EON;

void Func::setup()
{
    LOG("SETUP\n");

    m_wifiOn = false;
    m_mpuOn = false;
}

void Func::begin()
{
    LOG("BEGIN\n");
}

void Func::end()
{
    LOG("END\n");
}

#define F_ADD                0
#define F_SUB                1
#define F_MUL                2
#define F_DIV                3
#define F_GT                 4
#define F_LT                 5
#define F_GE                 6
#define F_LE                 7
#define F_EQ                 8
#define F_dw                 9
#define F_osc                10
#define F_wifiAP             11
#define F_wifiAPClientsCount 12
#define F_adc                13
#define F_tone               14
#define F_mpu6050Gyro        15
#define F_mpu6050Accel       16
#define F_madjwick           17
#define F_quat2json          18
#define F_wifi               19
#define F_wsBroadcast        20

#define ARG(type) (stack.pop().typedValue<type>())
#define HARG(type) (heap.get<type>(stack.pop().value.addr))
#define VALUE(v) (Value::floatValue(v))

Value Func::call(uint8_t opCode, Stack &stack, Heap &heap, Blob &blob)
{
    switch (opCode)
    {
        case F_ADD:
        {
            float x = ARG(float);
            float y = ARG(float);
            LOG("%f + %f\n", y, x);
            return VALUE(y + x);
        }

        case F_SUB:
        {
            float x = ARG(float);
            float y = ARG(float);
            LOG("%f - %f\n", y, x);
            return VALUE(y - x);
        }

        case F_MUL:
        {
            float x = ARG(float);
            float y = ARG(float);
            LOG("%f * %f\n", y, x);
            return VALUE(y * x);
        }

        case F_DIV:
        {
            float x = ARG(float);
            float y = ARG(float);
            LOG("%f / %f\n", y, x);
            return VALUE(y / x);
        }

        case F_GT:
        {
            float x = ARG(float);
            float y = ARG(float);
            LOG("%f > %f\n", y, x);
            return VALUE(y > x ? 1 : 0);
        }

        case F_LT:
        {
            float x = ARG(float);
            float y = ARG(float);
            LOG("%f < %f\n", y, x);
            return VALUE(y < x ? 1 : 0);
        }

        case F_GE:
        {
            float x = ARG(float);
            float y = ARG(float);
            LOG("%f >= %f\n", y, x);
            return VALUE(y >= x ? 1 : 0);
        }

        case F_LE:
        {
            float x = ARG(float);
            float y = ARG(float);
            LOG("%f <= %f\n", y, x);
            return VALUE(y <= x ? 1 : 0);
        }

        case F_EQ:
        {
            float x = ARG(float);
            float y = ARG(float);
            LOG("%f == %f\n", y, x);
            return VALUE(y == x ? 1 : 0);
        }

        case F_dw:
        {
            int x = ARG(int);
            int pin = ARG(int);
            LOG("digitalWrite %d %d\n", pin, x);
            MCU
            (
                digitalWrite(pin, x ? HIGH : LOW);
            )
            break;
        }

        case F_osc:
        {
            LOG("oscillate\n");
            break;
        }

        case F_wifiAP:
        {
            int passIdx = ARG(int);
            int ssidIdx = ARG(int);
            char pass[256];
            char ssid[256];
            blob.cString(passIdx, pass);
            blob.cString(ssidIdx, ssid);
            LOG("wifiAP <%s> <%s>\n", ssid, pass);
            MCU
            (
                if (!m_wifiOn)
                {
                    WiFi.softAP(ssid, pass);
                    m_wifiOn = true;
                }
            )
            break;
        }

        case F_wifiAPClientsCount:
        {
            uint8_t result = 0;
            LOG("wifiAPClientsCount\n");
            MCU
            (
                result = WiFi.softAPgetStationNum();
                Serial.print("WiFi clients: ");
                Serial.println(result);
            )
            return VALUE(result);
        }

        case F_adc:
        {
            int result = 0;
            LOG("adc\n");
            MCU
            (
                result = analogRead(0);
            )
            return VALUE(result);
        }

        case F_tone:
        {
            int freq = ARG(int);
            int pin = ARG(int);
            LOG("tone %d %d\n", pin, freq);
            pin = mapPin(pin);
            MCU
            (
                Serial.print("Tone: ");
                Serial.println(freq);
                if (freq > 0)
                    tone(pin, freq);
                else
                    noTone(pin);
            )
            break;
        }

        case F_mpu6050Gyro:
        {
            if (!m_mpuOn)
                initMPU();
            Vector gyro;
            MCU
            (
                gyro = m_mpu.readNormalizeGyro();
            )
            return Value::vec3Value(gyro.XAxis, gyro.YAxis, gyro.ZAxis, heap);
        }

        case F_mpu6050Accel:
        {
            if (!m_mpuOn)
                initMPU();
            Vector accel;
            MCU
            (
                accel = m_mpu.readNormalizeAccel();
            )
            return Value::vec3Value(accel.XAxis, accel.YAxis, accel.ZAxis, heap);
        }

        case F_madjwick:
        {
            float *accel = HARG(float);
            float *gyro = HARG(float);
            m_madjwick.FilterUpdate(gyro[0], gyro[1], gyro[2], accel[0], accel[1], accel[2]);
            Value result;
            result.type = Value::VEC4;
            result.value.addr = heap.alloc(4 * sizeof(float));
            float *quat = heap.get<float>(result.value.addr);
            m_madjwick.getQuaternion(quat[3], quat[0], quat[1], quat[2]);
            return result;
        }

        case F_quat2json:
        {
            float *quat = HARG(float);
            Offset nameIdx = ARG(Offset);

            char name[256];
            blob.cString(nameIdx, name);

            char json[256];
            sprintf(json, "\"%s\":[%.5f,%.5f,%.5f,%.5f]", name, quat[0], quat[1], quat[2], quat[3]);
            
            Value result;
            result.type = Value::DSTRING;
            result.value.addr = heap.alloc(strlen(json) + 1);
            strcpy(heap.get<char>(result.value.addr), json);
            return result;
        }

        case F_wifi:
        {
            bool isAP = ARG(bool);
            Offset mdnsIdx = ARG(Offset);
            Offset passIdx = ARG(Offset);
            Offset ssidIdx = ARG(Offset);
            if (!m_wifiOn)
            {
                char mdns[256];
                char pass[256];
                char ssid[256];
                blob.cString(mdnsIdx, mdns);
                blob.cString(passIdx, pass);
                blob.cString(ssidIdx, ssid);
                MCU
                (
                    IPAddress ip;
                    if (isAP)
                    {
                        WiFi.softAP(ssid, pass);
                        ip = WiFi.softAPIP();
                    }
                    else
                    {
                        WiFi.begin(ssid, pass);
                        int retry = 10;
                        Serial.print("Connecting");
                        while (WiFi.status() != WL_CONNECTED)
                        {
                            delay(500);
                            Serial.print(".");
                            --retry;
                            if (retry == 0)
                            {
                                WiFi.softAP("SciVi", "");
                                ip = WiFi.softAPIP();
                                Serial.println("Connection failed, falling back to SciVi access point");
                            }
                        }
                        if (retry > 0)
                            ip = WiFi.localIP();
                        Serial.println();
                    }
                    Serial.print("Connected, IP address: ");
                    Serial.println(ip);

                    if (g_MDNS.begin(mdns, ip))
                    {
                        g_MDNS.addService("http", "tcp", 80);
                        g_MDNS.addService("ws", "tcp", 81);
                        Serial.println("MDNS started");
                    }
                    else
                    {
                        Serial.println("MDNS failed");
                    }
                )
                m_wifiOn = true;
            }
            break;
        }

        case F_wsBroadcast:
        {
            char *json = HARG(char);

            MCU
            (
                char msg[256];
                sprintf(msg, "{%s}", json);
                g_webSocket.broadcastTXT(msg);
            )

            break;
        }
    }

    return Value::invalidValue();
}

int Func::mapPin(int pin) const
{
    static int mapping[] = { D0, D1, D2, D3, D4, D5, D6, D7, D8 };
    if (pin < 0)
        pin = 0;
    else if (pin >= sizeof(mapping))
        pin = sizeof(mapping) - 1;
    return mapping[pin];
}

void Func::initMPU()
{
    MCU
    (
        Wire.begin(4, 5);

        delay(100);

        while(!m_mpu.begin(MPU6050_SCALE_2000DPS, MPU6050_RANGE_2G))
        {
            Serial.println("Could not find a valid MPU6050 sensor, check wiring!");
            delay(500);
        }

        m_mpu.setAccelPowerOnDelay(MPU6050_DELAY_3MS);
        
        m_mpu.setIntFreeFallEnabled(false);  
        m_mpu.setIntZeroMotionEnabled(false);
        m_mpu.setIntMotionEnabled(false);
          
        m_mpu.setDHPFMode(MPU6050_DHPF_0_63HZ);
        m_mpu.setDLPFMode(MPU6050_DLPF_6);

        m_mpu.setMotionDetectionThreshold(8);
        m_mpu.setMotionDetectionDuration(5);

        m_mpu.setZeroMotionDetectionThreshold(4);
        m_mpu.setZeroMotionDetectionDuration(2);

        m_mpu.calibrateGyro(1000);
    )

    m_mpuOn = true;
}
